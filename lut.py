import numpy as np
from PIL import Image
from sklearn.linear_model import LinearRegression
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import PolynomialFeatures

def generate_lut_from_images(source_path, target_path, output_cube_name="style_match.cube", lut_size=33):
    print("1. Loading images...")
    # Load images and flatten to a list of pixels
    # We use a subset (e.g., every 50th pixel) to speed up training without losing accuracy
    source_img = Image.open(source_path).convert('RGB')
    target_img = Image.open(target_path).convert('RGB')
    
    # Resize for speed if images are huge (optional but recommended)
    source_img.thumbnail((500, 500))
    target_img.thumbnail((500, 500))

    source_pixels = np.array(source_img).reshape(-1, 3)
    target_pixels = np.array(target_img).reshape(-1, 3)

    print("2. Learning the color transformation...")
    # We use Polynomial Regression (Degree 2 or 3) because color grading is rarely linear
    # (e.g., shadows might be blue while highlights are yellow -> that's non-linear)
    model = make_pipeline(PolynomialFeatures(degree=2), LinearRegression())
    
    # Train the model: Input = Raw Pixels, Output = Edited Pixels
    model.fit(source_pixels, target_pixels)
    print(f"   Model Score (R^2): {model.score(source_pixels, target_pixels):.4f}")

    print("3. Generating 3D LUT...")
    # Create a generic 3D Identity Cube (Neutral LUT)
    # This represents every possible color in RGB space
    step = 255 / (lut_size - 1)
    # Generate grid coordinates
    r, g, b = np.meshgrid(
        np.arange(0, 256, step),
        np.arange(0, 256, step),
        np.arange(0, 256, step),
        indexing='ij'
    )
    
    # Flatten the grid to feed into our model
    lut_input = np.stack([r.flatten(), g.flatten(), b.flatten()], axis=1)
    
    # Predict what these neutral colors *should* look like based on your style
    lut_output = model.predict(lut_input)
    
    # Clip values to valid RGB range (0-255)
    lut_output = np.clip(lut_output, 0, 255)

    print("4. Saving .cube file...")
    write_cube_file(lut_output, output_cube_name, lut_size)
    print("Done! Load this .cube file into Photoshop/Lightroom.")

def write_cube_file(lut_data, filename, size):
    """Helper to write the standard Adobe .cube format"""
    with open(filename, 'w') as f:
        f.write(f'# Generated by Python Color Match\n')
        f.write(f'LUT_3D_SIZE {size}\n')
        
        # .cube format expects values 0.0 - 1.0
        lut_normalized = lut_data / 255.0
        
        for r, g, b in lut_normalized:
            f.write(f'{r:.6f} {g:.6f} {b:.6f}\n')

# --- Usage ---
generate_lut_from_images("sark.jpg", "lightpg.jpg")